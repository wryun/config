# this file basically makes 'es' look more like a modern bash prompt
# (in terms of following symlinks, colours, cd - (+ enhancements))

noexport = $noexport prompt history host
host = `hostname

# Frustratingly, BSD test doesn't support -l
fn strlen {
    if {~ $1 ()} {
        return 0
    } {
        return `{awk 'BEGIN { print length("'^$1^'") }'}
    }
}

# symlink cd (and pwd)
fn pwd {
    if {~ $#cwd 0} {
        noexport = $noexport cwd
        cwd = `` \n /bin/pwd
    }
    echo $cwd
}
let (cd = $fn-cd) fn cd dir {
    if {~ $#cwd 0} {
        noexport = $noexport cwd
    }
    if {~ $#dir 0} {
        $cd
        cwd = ~
    } {
        let (current = <={
            if {~ $dir /*} {
                result
            } {
                if {~ $#cwd 0} {
                    cwd = `` \n /bin/pwd
                }
                %split / $cwd
            }
        }) {
            for (name = <={%split / $dir}) {
                if {~ $name ..} {
                    if {!~ $#current 0} {
                        let (x = 1 $current) current = $x(2 ... $#current)
                    }
                } {!~ $name . ''} {
                    current = $current $name
                }
            }
            let (path = / ^ <={ %flatten / $current }) {
                $cd $path
                cwd = $path
            }
        }
    }
}

# go back -N directories in cd (cd -0 prints stack, cd - goes to previous)
#
let (cd = $fn-cd; cd-stack = ()) fn cd dir { 
    let (old = `pwd) {
        if {~ $dir -*} {
            let (index = <={~~ $dir -*}) {
                if {~ $index ''} {
                    index = 1
                }
                if {~ $index [1-9]} {
                    dir = $cd-stack($index)
                } {~ $index 0} {
                    for (i = `{seq $#cd-stack}) {
                        echo $i - $cd-stack($i)
                    }
                    return 0
                } {
                    throw error cd 'cd: invalid argument'
                }
            }
        }
        $cd $dir
        cd-stack = ($old $cd-stack(1 ... 9))
    }
}


fn cutdir dir {
    local (discard = (); small_dir = <={~~ $dir /*}) {
        while {test 50 -lt <={strlen $small_dir}} {
            (discard small_dir) = <={~~ $small_dir */*}
        }

        if {~ $discard ()} {
            return $dir
        } {
            return .../$small_dir
        }
    }
}

# make cd calculate current directory in pretty form
let (cd = $fn-cd) fn cd {
    $cd $*
    promptwd = `pwd
    promptwd = $^promptwd
    if {~ $promptwd $home^*} {
        promptwd = '/~'^<={~~ $promptwd $home^*}
    }

    promptwd = <={cutdir $promptwd}

    if {~ $promptwd '/~'*} {
        promptwd = <={~~ $promptwd /*}
    }
}

# window title
# This messes with the results (see #10). Can't use for now.
#let (parse = $fn-%parse) fn %parse prompt1 prompt2 {
#    if {~ $TERM xterm* rxvt*} {
#        echo -n \033]0\;$pwd' ('$USER'@'$host')'\007
#    }
#    cmd = <={$parse $prompt1 $prompt2}
#    if {~ $TERM xterm* rxvt*} {
#        echo -n \033]0\;$^cmd' ('$USER'@'$host')'\007
#    }
#    return $cmd
#}

# colourful programs with arguments
# remove ls for OSX
for (prog = grep) {
    let (o = `{whatis $prog}) fn $prog {$o --color\=auto $*}
}

# CLICOLOR...

if {~ $CLICOLOR ()} {
    let (o = `{whatis ls}) fn ls {$o --color $*}
}

# colourful programs with wrappers
# remove make... (messes with npm coloring)
for (prog = make diff gcc) {
    fn $prog { color$prog $* }
}

for (othergcc = g++ c++ cc) {
    fn $othergcc { colorgcc $* }
}

# Useful utils
fn lc {
  tail -r ~/.es_history | grep -v '^lc '^$^* | grep $^* | tail -r -n 20
}

# what to do for an interactive session
fn %prompt {
    stty -ixon # disable XOFF/XON (stop stupid C-s, esp. since readline uses it)
    history = $home/.es_history
    cd .

    fn %prompt {
        if {~ $TERM xterm* rxvt*} {
            echo -n \033]0\;$promptwd\007
        }

        # TODO God this is ugly. Separate prompt calculation...
        let (e = \033; a=\1; z=\2; branch=`{git rev-parse --abbrev-ref HEAD >[2] /dev/null}) {
            if {~ $branch ()} {branch = ''} {branch = ' ['^$branch^']'}
            prompt = $a$e[4\;35m$host$e^'[0m:'^$e^'[1;34m'^$promptwd$e^'[0m'^$branch$z^\n^'; '
        }
    }

    %prompt
}
